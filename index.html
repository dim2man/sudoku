<!doctype html>
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Судоку</title>
	<style type="text/css">
		* {margin: 0; padding: 0; box-sizing: border-box;}
		html {font-family: sans-serif;}
		h1 {font-size: 1rem; text-align: center; margin: 0.5rem 0;}
		button {cursor: pointer;}
		.container {display: flex; gap: 0.5rem;}
		#field {display: grid; margin: 0 calc(0.5rem - 1px); grid-template: repeat(9, 1rem) / repeat(9, 1rem); border: solid #000 1px; width: 9rem; box-sizing: content-box;}
		#field button {border: solid #ccc 1px; background-color: #fff; line-height: 1rem; vertical-align: middle; text-align: center; font-size: 0.7rem;color: #000;}
		#field button.solved {color: #336;}
		#field button[data-top] {border-top-color: #000;}
		#field button[data-left] {border-left-color: #000;}
		#field button[data-right] {border-right-color: #000;}
		#field button[data-bottom] {border-bottom-color: #000;}
		#field button.guess {display: grid;grid-template: repeat(3, calc(0.333rem - 1px)) / repeat(3, calc(0.333rem - 1px));font-size: 0.29rem; line-height: calc(0.333rem - 1px);}
		#field .selectedArea {background-color: #eee;}
		#field .selectedNum {background-color: #ccc;}
		html #field .error {background-color: #fcc; color: #f00;}
		html #field .selectedCell {background-color: #ccf;}
		#actions {display: flex; justify-content: space-around;}
		#buttons {display: flex; color: #000;}
		#buttons.guess {color: #336;}
		.number {width: 1rem; height: 1rem; line-height: 1rem; vertical-align: middle; text-align: center; border: none; background-color: #fff; font-size: 0.7rem; color: inherit;}
		#actions > * {width: 1rem; height: 1rem; background-color: #000; border: none; color: #fff;}
		#actions > #mode.guess {background-color: #336;}

		@media (orientation: landscape) {
			html {font-size: 8.333vh;}
			.container {flex-direction: row;}
			#actions {flex-direction: column;}
			#buttons {flex-direction: column;}
		}

		@media (orientation: portrait) {
			html {font-size: 10vw;}
			.container {flex-direction: column;}
			#actions {flex-direction: row; margin: 0 0.5rem;}
			#buttons {flex-direction: row; margin: 0 0.5rem;}
		}
	</style>
	<script type="text/javascript">
		const SELECTED_CLASSES = ['selectedCell', 'selectedArea', 'selectedNum'];
		const VALS=9;
		const SEED_PAIRS = [[0,0],[1,3],[2,6],[3,1],[4,4],[5,7],[6,2],[7,5],[8,8]];
		const SEED_BATCH_SIZE = 1000;
		let fieldEl, buttonsEl, modeEl, clearEl, nextEl, backEl;
		let field = [];
		const selected = {row: 0, col: 0, quad: 0, num: 0};
		let mode = 0; // 0 - write, 1 - guess
		let testCount = 0;
		let stackField = [];

		function handleCellClick(e) {
			const buttonEl = e.currentTarget;
			selected.row = +buttonEl.dataset.row;
			selected.col = +buttonEl.dataset.col;
			selected.quad = +buttonEl.dataset.quad;
			selected.num = +buttonEl.dataset.num;
			drawAllSelections();
		}

		function handleNumClick(e) {
			const buttonEl = e.currentTarget;
			const num = +buttonEl.dataset.num;
			if (selected.row && selected.col) {
				const cell = field[selected.row-1][selected.col-1];
				if (cell.fixed) return;
				if (mode === 0) {
					selected.num = num;
					cell.num = num;
				} else {
					selected.num = 0;
					cell.num = 0;
					const {guess} = cell;
					if (guess.has(num)) {
						guess.delete(num);
					} else {
						guess.add(num);
					}
				}
				drawNumber(selected.row, selected.col, cell);
				dropClassSelection('selectedNum');
				selected.num && drawSelection({num: selected.num}, 'selectedNum');
				drawErrors(getErrors(field));
			}
		}

		function handleModeClick() {
			mode = 1 - mode;
			drawMode();
		}

		function handleClearClick() {
			if (selected.row && selected.col) {
				const cell = field[selected.row-1][selected.col-1];
				if (cell.fixed) return;
				selected.num = 0;
				cell.num = 0;
				drawNumber(selected.row, selected.col, cell);
				dropClassSelection('selectedNum');
				drawErrors(getErrors(field));
			}
		}

		function handleNextClick() {
			testCount++;
			stackField.push(field);
			field = copySudoku(field);
			switch(testCount) {
				// case 1:
				// 	const pairs = getFilledNotFixedPairs(field);
				// 	if (pairs.length > 0) {
				// 		const rndPair = Math.floor(Math.random() * pairs.length);
				// 		const [r, c] = pairs[rndPair];
				// 		const tmpSudoku = copySudoku(field);
				// 		tmpSudoku[r][c].num = 0;
				// 		fillGuesses(tmpSudoku);
				// 		resolveSingleOptionsInSudoku(tmpSudoku);
				// 		if (isSudokuFinished(tmpSudoku)) {
				// 			field[r][c].num = 0;
				// 		} else {
				// 			field[r][c].fixed = true;
				// 		}
				// 		testCount--;
				// 	}
				// 	break;
				case 1:
					fillGuesses(field);
					break;
				default:
					resolveSingleOptionsInSudoku(field, false);
					break;
			}
			drawNumbers();
			drawErrors(getErrors(field));
		}

		function handleBackClick() {
			if (testCount) testCount--;
			if (stackField.length) {
				field = stackField.pop();
			}
			drawNumbers();
			drawErrors(getErrors(field));
		}

		function fillGuesses(sudoku) {
			traversSudoku(sudoku, ({num, guess}, r, c) => {
				if(!num) {
					for(let i=1; i<=VALS; i++) {
						guess.add(i);
					}
					for (let r2=0; r2<VALS; r2++) {
						guess.delete(sudoku[r2][c].num);
					}
					for (let c2=0; c2<VALS; c2++) {
						guess.delete(sudoku[r][c2].num);
					}
					const {q, i} = rc2qi(r, c);
					for (let i2=0; i2<VALS; i2++) {
						const {r: r2, c: c2} = qi2rc(q, i2);
						guess.delete(sudoku[r2][c2].num);
					}
				}
			});
		}

		function fixSudokuV0(sudoku, limit=0.5) {
			for(let r=0; r<VALS; r++) {
				for(let c=0; c<VALS; c++) {
					if (Math.random() > limit) {
						sudoku[r][c].fixed = true;	
					} else {
						sudoku[r][c].num = 0;
					}
				}
			}
			return sudoku;
		}

		function fixSudokuV1(sudoku) {
			let pairs = getFilledNotFixedPairs(sudoku);
			while (pairs.length > 0) {
				const rndPair = Math.floor(Math.random() * pairs.length);
				const [r, c] = pairs[rndPair];
				const tmpSudoku = copySudoku(sudoku);
				tmpSudoku[r][c].num = 0;
				fillGuesses(tmpSudoku);
				resolveSingleOptionsInSudoku(tmpSudoku);
				if (isSudokuFinished(tmpSudoku)) {
					sudoku[r][c].num = 0;
				} else {
					sudoku[r][c].fixed = true;
				}
				pairs = getFilledNotFixedPairs(sudoku);
			}
			return sudoku;
		}

		function genAndDrawNumbers() {
			let sudoku;
			while(true) {
				try {
					sudoku = genRandomSudoku();
					break;
				} catch(err) {
					console.error(err);
				}
			}

			field = fixSudokuV1(sudoku);

			drawNumbers();
		}


		function isValidSudoku(sudoku) {
			// check rows
			for(let r=0; r<VALS; r++) {
				const set = new Set();
				for (let c=0; c<VALS; c++) {
					if (sudoku[r][c].num) {
						if (set.has(sudoku[r][c].num)) return false;
						set.add(sudoku[r][c].num);
					}
				}
			}
			// check columns
			for (let c=0; c<VALS; c++) {
				const set = new Set();
				for(let r=0; r<VALS; r++) {
					if (sudoku[r][c].num) {
						if (set.has(sudoku[r][c].num)) return false;
						set.add(sudoku[r][c].num);
					}
				}
			}
			// check quadrants
			for(let q=0; q<VALS; q++) {
				const set = new Set();
				for (let i=0; i<VALS; i++) {
					const {r, c} = qi2rc(q, i);
					if (sudoku[r][c].num) {
						if (set.has(sudoku[r][c].num)) return false;
						set.add(sudoku[r][c].num);
					}
				}
			}
			return true;
		}

		function getErrors(sudoku) {
			const errors = new Set();
			// check rows
			for(let r=0; r<VALS; r++) {
				for (let c1=1; c1<VALS; c1++) {
					if (sudoku[r][c1].num) {
						for (let c2=0; c2<c1; c2++) {
							if (sudoku[r][c1].num == sudoku[r][c2].num) {
								errors.add(r*VALS + c1);
								errors.add(r*VALS + c2);
							}
						}
					}
				}
			}
			// check columns
			for (let c=0; c<VALS; c++) {
				for(let r1=1; r1<VALS; r1++) {
					if (sudoku[r1][c].num) {
						for(let r2=0; r2<r1; r2++) {
							if (sudoku[r1][c].num == sudoku[r2][c].num) {
								errors.add(r1*VALS + c);
								errors.add(r2*VALS + c);
							}
						}
					}
				}
			}
			// check quadrants
			for(let q=0; q<VALS; q++) {
				for (let i1=1; i1<VALS; i1++) {
					const {r: r1, c: c1} = qi2rc(q, i1);
					if (sudoku[r1][c1].num) {
						for (let i2=0; i2<i1; i2++) {
							const {r: r2, c: c2} = qi2rc(q, i2);
							if (sudoku[r1][c1].num == sudoku[r2][c2].num) {
								errors.add(r1*VALS + c1);
								errors.add(r2*VALS + c2);
							}
						}
					}
				}
			}
			return Array.from(errors)
				.map(i => [Math.floor(i/VALS), i%VALS])
				.filter(([r,c]) => !sudoku[r][c].fixed);
		}

		function getEmptySudoku() {
			const sudoku = [];
			for (let r=0; r<VALS; r++) {
				const row = [];
				for (let c=0; c<VALS; c++) {
					const guess = new Set();
					for (let v=1; v<=VALS; v++) guess.add(v);
					row.push({num: 0, guess});
				}
				sudoku.push(row);
			}
			return sudoku;
		}

		function traversSudoku(sudoku, func) {
			for (let r=0; r<VALS; r++) {
				for (let c=0; c<VALS; c++) {
					const res = func(sudoku[r][c], r, c);
					if (res) return;
				}
			}
		}

		function getGuessedPairs(sudoku) {
			const pairs = [];
			traversSudoku(sudoku, ({num, guess}, r, c) => {
				if(!num && guess.size > 1) {
					if (!pairs[guess.size]) pairs[guess.size] = [];
					pairs[guess.size].push([r,c]);
				}
			});
			for(let i=2; i<VALS; i++) {
				if(pairs[i] && pairs[i].length>0) return pairs[i];
			}
			return [];
		}

		function getFilledNotFixedPairs(sudoku) {
			const pairs = [];
			traversSudoku(sudoku, ({num, fixed}, r, c) => {
				if(num && !fixed) {
					pairs.push([r,c]);
				}
			});
			return pairs;
		}

		function copySudoku(sudoku) {
			const sudoku2 = [];
			traversSudoku(sudoku, (cell, r, c) => {
				if(!sudoku2[r]) sudoku2[r] = [];
				sudoku2[r][c] = {...cell, guess: new Set(cell.guess)}; 
			});
			return sudoku2;
		}

		function tryNumInSudoku(sudoku, {r, c, num}) {
			sudoku[r][c].num = num;
			for (let r2=0; r2<VALS; r2++) {
				sudoku[r2][c].guess.delete(num);
			}
			for (let c2=0; c2<VALS; c2++) {
				sudoku[r][c2].guess.delete(num);
			}
			const {q, i} = rc2qi(r, c);
			for (let i2=0; i2<VALS; i2++) {
				const {r: r2, c: c2} = qi2rc(q, i2);
				sudoku[r2][c2].guess.delete(num);
			}
		}

		function isSudokuValid(sudoku) {
			let valid = true;
			const rs = [], cs = [], qs = [];
			traversSudoku(sudoku, ({num, guess}, r, c) => {
				if (!num) {
					if (guess.size === 0) {
						valid = false;
						return true;
					}
					return;
				}
				const {q} = rc2qi(r, c);
				if (!rs[r]) rs[r] = new Set();
				if (!cs[c]) cs[c] = new Set();
				if (!qs[q]) qs[q] = new Set();
				if (rs[r].has(num) || cs[c].has(num) || qs[q].has(num)) {
					valid = false;
					return true;
				}
				rs[r].add(num);
				cs[c].add(num);
				qs[q].add(num);
			});
			return valid;
		}

		function resolveSingleOptionsInSudoku(sudoku, all=true) {
			let found;

			do {
				found = false;
				traversSudoku(sudoku, (cell, r, c) => {
					if(!cell.num) {
						if(cell.guess.size == 1) {
							cell.num = Array.from(cell.guess)[0];
							tryNumInSudoku(sudoku, {r, c, num: cell.num});
							found = true;
						}
					}
				});
			} while(found && all);
		}

		function isSudokuFinished(sudoku) {
			let finished = true;
			traversSudoku(sudoku, ({num}) => {
				if(!num) {
					finished = false;
					return true;
				}
			});
			return finished;
		}

		function genRandomSudoku() {
			let tryNum = 0;
			let sudoku = getEmptySudoku();
			const stack = [];
			const startTime = Date.now();

			// seed
			for(let i=0; i<SEED_PAIRS.length; i++) {
				const [r,c] = SEED_PAIRS[i];
				const {guess} = sudoku[r][c];
				const num = Array.from(guess)[Math.floor(Math.random()*guess.size)];
				tryNumInSudoku(sudoku, {r, c, num});
			}

			for(;tryNum<SEED_BATCH_SIZE; tryNum++) {
				resolveSingleOptionsInSudoku(sudoku);
				if (isSudokuValid(sudoku)) {
					if (isSudokuFinished(sudoku)) {
						console.log(`Generated sudoku in ${tryNum} steps and in ${Date.now() - startTime} ms`);
						break;
					}

					const pairs = getGuessedPairs(sudoku);
					const index = Math.floor(Math.random()*pairs.length);
					const [r, c] = pairs[index];
					const {guess} = sudoku[r][c];
					const num = Array.from(guess)[Math.floor(Math.random()*guess.size)];
					stack.push({
						sudoku: copySudoku(sudoku),
						r,
						c,
						num
					});
					tryNumInSudoku(sudoku, {r,c, num});
				} else {
					const {sudoku: prevSudoku, r, c, num} = stack.pop();
					sudoku = prevSudoku;
					sudoku[r][c].guess.delete(num);
				}
			}

			if (tryNum >= SEED_BATCH_SIZE) {
				throw `Failed to generate sudoku in ${SEED_BATCH_SIZE} steps`;
			}

			return sudoku;
		}

		function qi2rc(q, i) {
			const r = 3*Math.floor(q/3) + Math.floor(i/3);
			const c = 3*(q%3) + (i%3);
			return {r, c};
		}

		function rc2qi(r, c) {
			const q = 3*Math.floor(r/3) + Math.floor(c/3);
			const i = 3*(r%3) + (c%3);
			return {q, i};
		}

		function drawNumbers() {
			for(let r=1; r<=VALS; r++) {
				for(let c=1; c<=VALS; c++) {
					drawNumber(r, c, field[r-1][c-1]);
				}
			}
		}

		function drawNumber(row, col, {num, guess, fixed}) {
			const buttonEl = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);

			while (buttonEl.firstChild) buttonEl.firstChild.remove();

			if (num) {
				if (fixed) {
					buttonEl.classList.remove('solved');
				} else {
					buttonEl.classList.add('solved');
				}
				buttonEl.classList.remove('guess');
				buttonEl.dataset.num = num;
				buttonEl.appendChild(document.createTextNode(num));
				return;
			}

			buttonEl.classList.remove('solved');
			buttonEl.dataset.num = 0;
			if (guess.size > 0) {
				buttonEl.classList.add('guess');
				for(let v=1; v<=VALS; v++) {
					if (guess.has(v)) {
						const divEl = document.createElement('div');
						divEl.style.gridRow = Math.floor((v-1)/3) + 1;
						divEl.style.gridColumn = ((v-1) % 3) + 1;
						divEl.appendChild(document.createTextNode(v));
						buttonEl.appendChild(divEl);
					}
				}
			}
		}

		function dropClassSelection(cls) {
			Array.from(document.querySelectorAll(`.${cls}`)).forEach(el => 
				el.classList.remove(cls)
			);
		}

		function dropSelection() {
			SELECTED_CLASSES.forEach(dropClassSelection);
		}

		function drawSelection(types, cls) {
			Array.from(document.querySelectorAll(
				Object.entries(types)
					.reduce((acc, [type, val]) => `${acc}[data-${type}="${val}"]`, '')
			)).forEach(el => 
				el.classList.add(cls)
			);
		}

		function drawAllSelections() {
			dropSelection();
			selected.row && drawSelection({row: selected.row}, 'selectedArea');
			selected.col && drawSelection({col: selected.col}, 'selectedArea');
			selected.quad && drawSelection({quad: selected.quad}, 'selectedArea');
			selected.num && drawSelection({num: selected.num}, 'selectedNum');
			selected.row && selected.col && drawSelection({row: selected.row, col: selected.col}, 'selectedCell');
		}

		function drawMode() {
			if (mode === 0) {
				modeEl.classList.remove('guess');
				buttonsEl.classList.remove('guess');
			} else {
				modeEl.classList.add('guess');
				buttonsEl.classList.add('guess');
			}
		}

		function drawErrors(errors) {
			dropClassSelection('error');
			errors.forEach(([r, c]) => drawSelection({row: r+1, col: c+1}, 'error'));
		} 

		function initFieldEl() {
			for(let r=1; r<=VALS; r++) {
				for(let c=1; c<=VALS; c++) {
					const buttonEl = document.createElement('button');
					buttonEl.style.gridRow = r;
					buttonEl.style.gridColumn = c;
					buttonEl.dataset.row = r;
					buttonEl.dataset.col = c;
					buttonEl.dataset.quad = rc2qi(r-1, c-1).q + 1;
					buttonEl.dataset.num = 0;
					if(r%3 === 1) buttonEl.dataset.top = true;
					if(r%3 === 0) buttonEl.dataset.bottom = true;
					if(c%3 === 1) buttonEl.dataset.left = true;
					if(c%3 === 0) buttonEl.dataset.right = true;
					buttonEl.addEventListener('click', handleCellClick);
					fieldEl.appendChild(buttonEl);
				}
			}
		}

		function initButtonsEl() {
			for(let v=1; v<=VALS; v++) {
				const buttonEl = document.createElement('button');
				buttonEl.dataset.num = v;
				buttonEl.addEventListener('click', handleNumClick);
				buttonEl.classList.add('number');
				buttonEl.appendChild(document.createTextNode(v));
				buttonsEl.appendChild(buttonEl);
			}
		}

		function initActions() {
			modeEl = document.getElementById('mode');
			clearEl = document.getElementById('clear');
			nextEl = document.getElementById('next');
			backEl = document.getElementById('back');

			modeEl.addEventListener('click', handleModeClick);
			clearEl.addEventListener('click', handleClearClick);
			nextEl.addEventListener('click', handleNextClick);
			backEl.addEventListener('click', handleBackClick);
			drawMode();
		}


		function init() {
			fieldEl = document.getElementById('field');
			buttonsEl = document.getElementById('buttons');
			initFieldEl();
			initButtonsEl();
			initActions();
			genAndDrawNumbers();
		}

		window.onload = init;
	</script>
</head>
<body>
	<h1>Судоку</h1>
	<div class="container">
		<div id="field"></div>
		<div id="actions">
			<button id="mode">M</button>
			<button id="clear">C</button>
			<button id="next">N</button>
			<button id="back">B</button>
		</div>
		<div id="buttons"></div>
	</div>
</body>
</html>
