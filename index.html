<!doctype html>
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Судоку</title>
	<style type="text/css">
		* {margin: 0; padding: 0; box-sizing: border-box;}
		html {font-family: sans-serif;}
		h1 {font-size: 1rem; text-align: center; margin: 0.5rem 0;}
		button {cursor: pointer;}
		.container {display: flex; gap: 0.5rem;}
		#field {display: grid; margin: 0 calc(0.5rem - 1px); grid-template: repeat(9, 1rem) / repeat(9, 1rem); border: solid #000 1px; width: 9rem; box-sizing: content-box;}
		#field button {border: solid #ccc 1px; background-color: #fff; line-height: 1rem; vertical-align: middle; text-align: center; font-size: 0.7rem;color: #000;}
		#field button.solved {color: #336;}
		#field button[data-top] {border-top-color: #000;}
		#field button[data-left] {border-left-color: #000;}
		#field button[data-right] {border-right-color: #000;}
		#field button[data-bottom] {border-bottom-color: #000;}
		#field button.guess {display: grid;grid-template: repeat(3, calc(0.333rem - 1px)) / repeat(3, calc(0.333rem - 1px));font-size: 0.29rem; line-height: calc(0.333rem - 1px);}
		#field .selectedArea {background-color: #eee;}
		#field .selectedNum {background-color: #ccc;}
		html #field .selectedCell {background-color: #ccf;}
		#options {display: flex; justify-content: space-around;}
		#buttons {display: flex; color: #000;}
		#buttons.guess {color: #336;}
		.number {width: 1rem; height: 1rem; line-height: 1rem; vertical-align: middle; text-align: center; border: none; background-color: #fff; font-size: 0.7rem; color: inherit;}
		#mode {width: 1rem; height: 1rem; background-color: #000; border: none;}
		#mode.guess {background-color: #336;}

		@media (orientation: landscape) {
			html {font-size: 8.333vh;}
			.container {flex-direction: row;}
			#options {flex-direction: column;}
			#buttons {flex-direction: column;}
		}

		@media (orientation: portrait) {
			html {font-size: 10vw;}
			.container {flex-direction: column;}
			#options {flex-direction: row; margin: 0 0.5rem;}
			#buttons {flex-direction: row; margin: 0 0.5rem;}
		}
	</style>
	<script type="text/javascript">
		const SELECTED_CLASSES = ['selectedCell', 'selectedArea', 'selectedNum'];
		const VALS=9;
		const SEED_PAIRS = [[0,0],[1,3],[2,6],[3,1],[4,4],[5,7],[6,2],[7,5],[8,8]];
		const SEED_BATCH_SIZE = 10000;
		let fieldEl, buttonsEl, modeEl;
		const field = [];
		const selected = {row: 0, col: 0, quad: 0, num: 0};
		let mode = 0; // 0 - write, 1 - guess 

		function handleCellClick(e) {
			const buttonEl = e.currentTarget;
			selected.row = +buttonEl.dataset.row;
			selected.col = +buttonEl.dataset.col;
			selected.quad = +buttonEl.dataset.quad;
			selected.num = +buttonEl.dataset.num;
			drawAllSelections();
		}

		function handleNumClick(e) {
			const buttonEl = e.currentTarget;
			const num = +buttonEl.dataset.num;
			if (selected.row && selected.col) {
				const cell = field[selected.row-1][selected.col-1];
				if (cell.fixed) return;
				if (mode === 0) {
					selected.num = num;
					cell.num = num;
				} else {
					selected.num = 0;
					cell.num = 0;
					const {guess} = cell;
					if (guess.has(num)) {
						guess.delete(num);
					} else {
						guess.add(num);
					}
				}
				drawNumber(selected.row, selected.col, cell);
				dropClassSelection('selectedNum');
				selected.num && drawSelection({num: selected.num}, 'selectedNum');
			}
		}

		function handleModeClick() {
			mode = 1 - mode;
			drawMode();
		}

		function genAndDrawNumbers() {
			genRandomSudoku()
				.then(function(sudoku) {
					for(let r=0; r<VALS; r++) {
						field[r] = [];
						for(let c=0; c<VALS; c++) {
							const {num, guess} = sudoku[r][c];
							const fixed = Math.random() > 0.4;
							field[r][c] = {
								num: fixed ? num : 0,
								fixed,
								guess: new Set()
							};
						}
					}
					drawNumbers();
				})
				.catch(function(err) {
					console.error(err);
				});
		}


		function isValidSudoku(sudoku) {
			// check rows
			for(let r=0; r<VALS; r++) {
				const set = new Set();
				for (let c=0; c<VALS; c++) {
					if (sudoku[r][c].num) {
						if (set.has(sudoku[r][c].num)) return false;
						set.add(sudoku[r][c].num);
					}
				}
			}
			// check columns
			for (let c=0; c<VALS; c++) {
				const set = new Set();
				for(let r=0; r<VALS; r++) {
					if (sudoku[r][c].num) {
						if (set.has(sudoku[r][c].num)) return false;
						set.add(sudoku[r][c].num);
					}
				}
			}
			// check quadrants
			for(let q=0; q<VALS; q++) {
				const set = new Set();
				for (let i=0; i<VALS; i++) {
					const {r, c} = qi2rc(q, i);
					if (sudoku[r][c].num) {
						if (set.has(sudoku[r][c].num)) return false;
						set.add(sudoku[r][c].num);
					}
				}
			}
			return true;
		}


		function getEmptySudoku() {
			const sudoku = [];
			for (let r=0; r<VALS; r++) {
				const row = [];
				for (let c=0; c<VALS; c++) {
					const guess = new Set();
					for (let v=1; v<=VALS; v++) guess.add(v);
					row.push({num: 0, guess});
				}
				sudoku.push(row);
			}
			return sudoku;
		}

		function traversSudoku(sudoku, func) {
			for (let r=0; r<VALS; r++) {
				for (let c=0; c<VALS; c++) {
					const res = func(sudoku[r][c], r, c);
					if (res) return;
				}
			}
		}

		function getNonfixedPairs(sudoku) {
			const pairs = [];
			traversSudoku(sudoku, ({num, guess}, r, c) => {
				if(!num && guess.size > 1) {
					if (!pairs[guess.size]) pairs[guess.size] = [];
					pairs[guess.size].push([r,c]);
				}
			});
			for(let i=2; i<VALS; i++) {
				if(pairs[i] && pairs[i].length>0) return pairs[i];
			}
			//return pairs.reduce((acc, p) => [...acc, ...p], []);
			return [];
		}

		function copySudoku(sudoku) {
			const sudoku2 = [];
			traversSudoku(sudoku, ({num, guess}, r, c) => {
				if(!sudoku2[r]) sudoku2[r] = [];
				sudoku2[r][c] = {num, guess: new Set(guess)}; 
			});
			return sudoku2;
		}

		function tryNumInSudoku(sudoku, {r, c, num}) {
			sudoku[r][c].num = num;
			for (let r2=0; r2<VALS; r2++) {
				sudoku[r2][c].guess.delete(num);
			}
			for (let c2=0; c2<VALS; c2++) {
				sudoku[r][c2].guess.delete(num);
			}
			const {q, i} = rc2qi(r, c);
			for (let i2=0; i2<VALS; i2++) {
				const {r: r2, c: c2} = qi2rc(q, i2);
				sudoku[r2][c2].guess.delete(num);
			}
		}

		function isSudokuValid(sudoku) {
			let valid = true;
			const rs = [], cs = [], qs = [];
			traversSudoku(sudoku, ({num, guess}, r, c) => {
				if (!num) {
					if (guess.size === 0) {
						valid = false;
						return true;
					}
					return;
				}
				const {q} = rc2qi(r, c);
				if (!rs[r]) rs[r] = new Set();
				if (!cs[c]) cs[c] = new Set();
				if (!qs[q]) qs[q] = new Set();
				if (rs[r].has(num) || cs[c].has(num) || qs[q].has(num)) {
					valid = false;
					return true;
				}
				rs[r].add(num);
				cs[c].add(num);
				qs[q].add(num);
			});
			return valid;
		}

		function resolveSingleOptionsInSudoku(sudoku) {
			let found;

			do {
				found = false;
				const opts_r = [];
				const opts_c = [];
				const opts_q = [];
				traversSudoku(sudoku, (cell, r, c) => {
					if(!cell.num) {
						if(cell.guess.size == 1) {
							cell.num = Array.from(cell.guess)[0];
							tryNumInSudoku(sudoku, {r, c, num: cell.num});
							found = true;
						} else {
							const {q, i} = rc2qi(r, c);
							for (let num of cell.guess) {
								if(!opts_r[r]) opts_r[r]={};
								if(!opts_r[r][num]) opts_r[r][num] = new Set();
								opts_r[r][num].add(c);
								if(!opts_c[c]) opts_c[c]={};
								if(!opts_c[c][num]) opts_c[c][num] = new Set();
								opts_c[c][num].add(r);
								if(!opts_q[q]) opts_q[q]={};
								if(!opts_q[q][num]) opts_q[q][num] = new Set();
								opts_q[q][num].add(i);
							}
						}
					}
				});
				for(let j=0; j<VALS; j++) {
					for(let num=1; num<=VALS; num++) {
						if(opts_r[j] && opts_r[j][num] && opts_r[j][num].size == 1) {
							const r = j;
							const c = Array.from(opts_r[j][num])[0];
							tryNumInSudoku(sudoku, {r, c, num});
							found = true;
						}
						if(opts_c[j] && opts_c[j][num] && opts_c[j][num].size == 1) {
							const r = Array.from(opts_c[j][num])[0];
							const c = j;
							tryNumInSudoku(sudoku, {r, c, num});
							found = true;
						}
						if(opts_q[j] && opts_q[j][num] && opts_q[j][num].size == 1) {
							const q = j;
							const i = Array.from(opts_q[j][num])[0];
							const {r, c} = qi2rc(q, i);
							tryNumInSudoku(sudoku, {r, c, num});
							found = true;
						}
					}	
				}
			} while(found);
		}

		function isSudokuFinished(sudoku) {
			let finished = true;
			traversSudoku(sudoku, ({num}) => {
				if(!num) {
					finished = false;
					return true;
				}
			});
			return finished;
		}

		function countOpts(sudoku) {
			let opts = 0;
			traversSudoku(sudoku, ({num, guess}) => {
				if (!num) opts += guess.size;
			});
			return opts;
		}


		function genRandomSudoku() {
			return new Promise(function(resolve, reject) {
				let tryNum = 0;
				let sudoku = getEmptySudoku();
				const stack = [];
				const startTime = Date.now();

				// seed
				for(let i=0; i<SEED_PAIRS.length; i++) {
					const [r,c] = SEED_PAIRS[i];
					const {guess} = sudoku[r][c];
					const num = Array.from(guess)[Math.floor(Math.random()*guess.size)];
					tryNumInSudoku(sudoku, {r, c, num});
				}

				function next() {
					for(let i=0; i<SEED_BATCH_SIZE; i++) {
						tryNum++;
						resolveSingleOptionsInSudoku(sudoku);
						if (isSudokuValid(sudoku)) {
							if (isSudokuFinished(sudoku)) {
								console.log(`Generated sudoku in ${tryNum} steps and in ${Date.now() - startTime} ms`);
								resolve(sudoku);
								return;
							}

							const pairs = getNonfixedPairs(sudoku);
							const index = Math.floor(Math.random()*pairs.length);
							const [r, c] = pairs[index];
							const {guess} = sudoku[r][c];
							const num = Array.from(guess)[Math.floor(Math.random()*guess.size)];
							stack.push({
								sudoku: copySudoku(sudoku),
								r,
								c,
								num
							});
							tryNumInSudoku(sudoku, {r,c, num});
						} else {
							const {sudoku: prevSudoku, r, c, num} = stack.pop();
							sudoku = prevSudoku;
							sudoku[r][c].guess.delete(num);
						}
					}
					setTimeout(next, 0);
				}
				setTimeout(next, 0);
			});
		}

		function qi2rc(q, i) {
			const r = 3*Math.floor(q/3) + Math.floor(i/3);
			const c = 3*(q%3) + (i%3);
			return {r, c};
		}

		function rc2qi(r, c) {
			const q = 3*Math.floor(r/3) + Math.floor(c/3);
			const i = 3*(r%3) + (c%3);
			return {q, i};
		}

		function drawNumbers() {
			for(let r=1; r<=VALS; r++) {
				for(let c=1; c<=VALS; c++) {
					drawNumber(r, c, field[r-1][c-1]);
				}
			}
		}

		function drawNumber(row, col, {num, guess, fixed}) {
			const buttonEl = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);

			while (buttonEl.firstChild) buttonEl.firstChild.remove();

			if (num) {
				if (!fixed) {
					buttonEl.classList.add('solved');
				}
				buttonEl.classList.remove('guess');
				buttonEl.dataset.num = num;
				buttonEl.appendChild(document.createTextNode(num));
				return;
			}

			buttonEl.classList.remove('solved');
			if (guess.size > 0) {
				buttonEl.classList.add('guess');
				for(let v=1; v<=VALS; v++) {
					if (guess.has(v)) {
						const divEl = document.createElement('div');
						divEl.style.gridRow = Math.floor((v-1)/3) + 1;
						divEl.style.gridColumn = ((v-1) % 3) + 1;
						divEl.appendChild(document.createTextNode(v));
						buttonEl.appendChild(divEl);
					}
				}
			}
		}

		function dropClassSelection(cls) {
			Array.from(document.querySelectorAll(`.${cls}`)).forEach(el => 
				el.classList.remove(cls)
			);
		}

		function dropSelection() {
			SELECTED_CLASSES.forEach(dropClassSelection);
		}

		function drawSelection(types, cls) {
			Array.from(document.querySelectorAll(
				Object.entries(types)
					.reduce((acc, [type, val]) => `${acc}[data-${type}="${val}"]`, '')
			)).forEach(el => 
				el.classList.add(cls)
			);
		}

		function drawAllSelections() {
			dropSelection();
			selected.row && drawSelection({row: selected.row}, 'selectedArea');
			selected.col && drawSelection({col: selected.col}, 'selectedArea');
			selected.quad && drawSelection({quad: selected.quad}, 'selectedArea');
			selected.num && drawSelection({num: selected.num}, 'selectedNum');
			selected.row && selected.col && drawSelection({row: selected.row, col: selected.col}, 'selectedCell');
		}

		function drawMode() {
			if (mode === 0) {
				modeEl.classList.remove('guess');
				buttonsEl.classList.remove('guess');
			} else {
				modeEl.classList.add('guess');
				buttonsEl.classList.add('guess');
			}
		}

		function initFieldEl() {
			for(let r=1; r<=VALS; r++) {
				for(let c=1; c<=VALS; c++) {
					const buttonEl = document.createElement('button');
					buttonEl.style.gridRow = r;
					buttonEl.style.gridColumn = c;
					buttonEl.dataset.row = r;
					buttonEl.dataset.col = c;
					buttonEl.dataset.quad = rc2qi(r-1, c-1).q + 1;
					buttonEl.dataset.num = 0;
					if(r%3 === 1) buttonEl.dataset.top = true;
					if(r%3 === 0) buttonEl.dataset.bottom = true;
					if(c%3 === 1) buttonEl.dataset.left = true;
					if(c%3 === 0) buttonEl.dataset.right = true;
					buttonEl.addEventListener('click', handleCellClick);
					fieldEl.appendChild(buttonEl);
				}
			}
		}

		function initButtonsEl() {
			for(let v=1; v<=VALS; v++) {
				const buttonEl = document.createElement('button');
				buttonEl.dataset.num = v;
				buttonEl.addEventListener('click', handleNumClick);
				buttonEl.classList.add('number');
				buttonEl.appendChild(document.createTextNode(v));
				buttonsEl.appendChild(buttonEl);
			}
		}

		function initModeEl() {
			modeEl.addEventListener('click', handleModeClick);
			drawMode();
		}

		function init() {
			fieldEl = document.getElementById('field');
			buttonsEl = document.getElementById('buttons');
			modeEl = document.getElementById('mode');
			initFieldEl();
			initButtonsEl();
			initModeEl();
			genAndDrawNumbers();
		}

		window.onload = init;
	</script>
</head>
<body>
	<h1>Судоку</h1>
	<div class="container">
		<div id="field"></div>
		<div id="options"><button id="mode"></button></div>
		<div id="buttons"></div>
	</div>
</body>
</html>
